```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", 
  warning = F,
  message = F
)
```

```{r, include = FALSE}
library(regress3d)
library(plotly)
library(stargazer)
la_counties <- subset(county_data, state_abbrv == "LA")
model1 <- lm(prcnt_GOP16 ~ median_income16_1k,  data = la_counties)
model2 <- lm(prcnt_GOP16 ~ median_income16_1k + prcnt_black, data = la_counties)
model3 <- lm(prcnt_black ~ median_income16_1k, data = la_counties)

```

# Visualizing the Nested Model Inside the Full Model {#sec-viz}

[*Author's note*]{.underline}*: The following demonstrates the numeric equivalency of* $\hat{\beta}_1$ *from Model* \ref{ypredbyx1} *with the slope in the direction of* $\hat{\gamma}$ *in the full model (Model* \ref{ypredbyx1x2}*) for one example. A pdf with the proof that this holds for all linear nested models of this type (one * $x$ *variable in the nested model, two * $x$ *variables in the full model) can be found at my [github repository](https://github.com/ellaFosterMolina/interpret-nested-models/blob/master/interpret-nested-models-rotations.pdf) for this document.*

## Visualizing Model 1: The nested model with one x variable

For reference, the equation for the estimated values of the nested model (Model \ref{ypredbyx1}) is:

\begin{align}
\hat{y} =& \hat{\beta}_1 x_1 + \hat{\beta}_0. \label{ypredbyx1}
\end{align}

The standard way to visualize Model \ref{ypredbyx1} is in 2 dimensions using a scatterplot with a regression line.

```{r}
la_counties %>%
  ggplot(aes(x = median_income16_1k, y = prcnt_GOP16)) +
  geom_point()+
  geom_smooth(method = lm)+
  theme_classic()+
  labs(y = "% of County that Voted for Trump in 2016",
       x = "County median income")
```

## Visualizing Model 2: The model with two x variables

The equation for the estimated values of the full model (Model \ref{ypredbyx1x2}) is:

\begin{align}
\hat{y} =& \hat{\beta}'_1 x_1 +\hat{\beta}'_2 x_2 + \hat{\beta}'_0. \label{ypredbyx1x2}
\end{align}

Before we see the nested model (Model \ref{ypredbyx1}) in 3D, we can examine the regression surface for Model \ref{ypredbyx1x2} visualized in 3D. The [regression surface]{style="color: blue;"} is shown in blue. The [confidence interval surfaces]{style="color: grey;"} are shown in grey. The marginal effects of `median_income16_1k` in [orange]{style="color: orange;"} and `prcnt_black` in [red]{style="color: red;"} are depicted for reference.

A more thorough explanation of the code used to create the regression surface and marginal effects, as well as more instructions on how to interact with the 3D graphic can be found [here](https://ellafostermolina.github.io/regress3d/articles/linear_models_3d.html).

```{r}
plot_ly( data = la_counties,
         x = ~median_income16_1k,
         y = ~prcnt_black,
         z = ~prcnt_GOP16) %>%
  add_markers(size = ~pop_estimate16, color = I("black"),
              name ="Louisiana county") %>%
  add_3d_surface(model = model2)%>%
  add_marginals(model = model2, 
                x1_direction_name ="Marginal effect of income",
                x2_direction_name ="Marginal effect of % Black")
```

Click-hold-drag the image above to rotate it and see the regression surface from different perspectives.

## Visualizing Model 1 Nested Inside Model 2 {#sec-viznest}

The nested model can be shown within the regression surface generated by Model \ref{ypredbyx1x2}. This section will demonstrate how to do this. @sec-vizdir will then demonstrate that the predicted $y$ values in the nested model (Model \ref{ypredbyx1}) are indeed identical to the predicted values in the regression surface (Model \ref{ypredbyx1x2}) in the direction defined by $\hat{\gamma}_{1}$ from Model \ref{x1predbyx2}:

\begin{align}
  \hat{x}_2 =& \hat{\gamma}_{1} x_1 + \hat{\gamma}_{0}. \label{x1predbyx2}
\end{align}

### Create predicted values data

In order to visualize Model 1 nested inside the [regression surface]{style="color: blue;"} of Model 2, we will create a data set of generated and predicted values. This will be used to plot the estimated values of `prcnt_GOP16` in the 3D graphic.

1.  `income_seq` is a sequence of values from the lowest value for `median_income16_1k` to the highest.

```{r}
income_seq <-  seq(min(la_counties$median_income16_1k, na.rm=TRUE),
                   max(la_counties$median_income16_1k, na.rm=TRUE),
                   length.out=10) 
income_seq <- data.frame(median_income16_1k =income_seq)
```

2.  `predicted_gop` is a dataframe that contains predicted values for `prcnt_GOP16` based on Model \ref{ypredbyx1} and the values in `income_seq`. Note that there is no explicit information about `prcnt_black` in the prediction.

-   `predicted_gop` also contains the lower and upper 95% confidence intervals for the predicted values.

```{r}
predicted_gop <- predict(object = model1, newdata = income_seq, 
                         interval = "confidence") %>%
  as.data.frame(.)
```

3.  `predicted_prcnt_black` is a sequence of predicted values for `prcnt_black` based on Model \ref{x1predbyx2} and the values in `income_seq`. This sequence of values is exclusively used to plot the estimated values for `prcnt_GOP16` in the $\hat{\gamma}_{1}$ direction of the regression surface.

```{r}
predicted_prcnt_black <- predict(object = model3, newdata = income_seq)
```

We then turn these values into a dataframe that **regress_3d** can use to create lines in 3D.

```{r}
simulated_data_nested_model <- data.frame(median_income16_1k = income_seq,
                                          prcnt_black = predicted_prcnt_black,
                                          prcnt_GOP16 = predicted_gop$fit,
                                          lowerCI = predicted_gop$lwr,
                                          upperCI = predicted_gop$upr)
```

### Create 3D visual

The nested model is shown in black in the regression surface generated by Model \ref{ypredbyx1x2}.

```{r}
plot_ly( data = la_counties,
         x = ~median_income16_1k,
         y = ~prcnt_black,
         z = ~prcnt_GOP16) %>%
  add_markers(size = ~pop_estimate16, color = I("black"),
              name = "Louisiana counties") %>%
  add_3d_surface(model = model2)%>%
  add_direction(model = model2, direction_data = simulated_data_nested_model,
                direction_name = "Nested model: 
                prcnt_GOP16 ~ median_income16_1k, omitting prcnt_black")%>%
  layout(legend = list(orientation = 'h'))
# the function add_direction() calls model2.  
# The model is exclusively used to ensure that the variable names
# in direction_data are the same as in the full model (Model 2), 
# and therefore plottable in the same coordinate system as the regression surface. 
# Model 2 is not used to estimate any values.
# The function will be edited in the future to ensure there is no confusion.
```

### Results

-   The **black** line of predicted values for `prcnt_GOP16` appear to lie exactly on the [blue regression plane]{style="color: blue;"} generated by Model \ref{ypredbyx1x2}. *This occurs despite the fact that education was not used to generate the estimates for the predicted values of `prcnt_GOP16`.*
-   The confidence intervals for `prcnt_GOP16` lie outside the [grey confidence intervals]{style="color: grey;"} for the regression plane generated by Model \ref{ypredbyx1x2}.

@sec-vizdir below will demonstrate that the predicted values of `prcnt_GOP16` are precisely on the [regression plane]{style="color: blue;"} generated by Model \ref{ypredbyx1x2}. We will generate the predicted values for `prcnt_GOP16` from Model \ref{ypredbyx1x2} using the paired values ($x_1$, $x_2$) = (`median_income16_1k`, `prcnt_black`), where the value for $x_2$ is predicted by Model \ref{x1predbyx2}, `prcnt_black` \~ `median_income16_1k`.

## Visualizing A Direction in Model 1 with the Same Predicted Values as the Nested Model {#sec-vizdir}

@sec-viznest predicted values for `prcnt_GOP16` using Model \ref{ypredbyx1}, a model that includes `median_income_1k` but has no information about `prcnt_black`. This section will predict values for `prcnt_GOP16` using Model \ref{ypredbyx1x2}, a model that includes both `median_income_1k` and `prcnt_black`.

### Create predicted values data

1.  `income_seq`: As in @sec-viznest, this is a sequence of values from the lowest value for `median_income16_1k` to the highest.
2.  `predicted_prcnt_black`: As in @sec-viznest, this is a sequence of predicted values for `prcnt_black` based on Model \ref{x1predbyx2} and the values in `income_seq`. We bind these values into a dataframe to be used to generate `predicted_rshift`. Unlike @sec-viznest, these values will be used to predict the values for $y$ (`prcnt_GOP16`) using Model \ref{ypredbyx1x2}.

```{r}
income_edu_data <- data.frame(median_income16_1k = income_seq,
                              prcnt_black = predicted_prcnt_black)
```

3.  `predicted_gop`: is a dataframe that contains predicted values for `prcnt_GOP16` based on Model \ref{ypredbyx1x2} and the values in `income_edu_data`. It also contains the lower and upper 95% confidence intervals for the predicted values.

```{r}
predicted_gop <- predict(object = model2, newdata = income_edu_data, interval = "confidence") %>%
  as.data.frame(.)
```

We then turn these values into a dataframe that **regress_3d** can use to create lines in 3D.

```{r}
simulated_data_model2 <- data.frame(median_income16_1k = income_seq,
                                    prcnt_black = predicted_prcnt_black,
                                    prcnt_GOP16 = predicted_gop$fit,
                                    lowerCI = predicted_gop$lwr,
                                    upperCI = predicted_gop$upr)
```

### Create 3D visual

The nested model from @sec-viznest is shown with the [black line]{style="color: black;"}. The [green line]{style="color: green;"} shows the estimated values of `prcnt_GOP16` in the $\gamma_1$ direction of the $(x_1, x_2)$ = (`median_income16_1k`, `prcnt_black`) coordinate system.

```{r}
plot_ly( data = la_counties,
         x = ~median_income16_1k,
         y = ~prcnt_black,
         z = ~prcnt_GOP16) %>%
  add_markers(size = ~pop_estimate16, color = I("black"),
              name = "Louisiana counties") %>%
  add_direction(model = model2, direction_data = simulated_data_nested_model,
                direction_name = "Nested model: 
                prcnt_GOP16 ~ median_income16_1k, omitting prcnt_black") %>%
  add_direction(model = model2, direction_data = simulated_data_model2,
                linecolor = "green",
                direction_name = "The &#947;&#x0302; direction in Model 2:
                prcnt_GOP16 ~ median_income16_1k + prcnt_black")%>%
  layout(legend = list(orientation = 'h'))
# the function add_direction() calls model2.  
# The model is exclusively used to ensure that the variable names
# in direction_data are the same as in the full model (Model 2), 
# and therefore plottable in the same coordinate system as the regression surface. 
# Model 2 is not used to estimate any values.
# The function will be edited in the future to ensure there is no confusion.
```

### Results

-   These two lines look identical:
    -   The [green]{style="color: green;"} line of estimated values for `prcnt_GOP16` based on Model \ref{ypredbyx1x2} in the $\gamma_1$ direction estimated from Model \ref{x1predbyx2}: `prcnt_black` \~ `median_income16_1k`
    -   The [black]{style="color: black;"} line of values for `prcnt_GOP16` estimated from Model \ref{ypredbyx1} which does not have any information about `prcnt_black`.

The table below shows that they are identical to a numeric error. Specifically, they are identical within 13 significant digits, which is within the precision that R can estimate values.

```{r}
diff_model1_model2 <- simulated_data_nested_model$prcnt_GOP16 - simulated_data_model2$prcnt_GOP16
data.frame(model1_rshift =  simulated_data_nested_model$prcnt_GOP16,
           model2_rshift =  simulated_data_model2$prcnt_GOP16, 
           diff = round(diff_model1_model2, digits = 13) )
```

The **black** and [green]{style="color: green;"} directions are plotted below [blue regression surface]{style="color: blue;"}.

```{r}
plot_ly( data = la_counties,
         x = ~median_income16_1k,
         y = ~prcnt_black,
         z = ~prcnt_GOP16) %>%
  add_markers(size = ~pop_estimate16, color = I("black"),
              name = "Louisiana counties") %>%
  add_3d_surface(model = model2)%>%
  add_direction(model = model2, direction_data = simulated_data_nested_model,
                direction_name = "Nested model: 
                prcnt_GOP16 ~ median_income16_1k, omitting prcnt_black") %>%
  add_direction(model = model2, direction_data = simulated_data_model2,
                linecolor = "green",
                direction_name = "The &#947;&#x0302; direction in Model 2:
                prcnt_GOP16 ~ median_income16_1k + prcnt_black")%>%
  layout(legend = list(orientation = 'h'))
# the function add_direction() calls model2.  
# The model is exclusively used to ensure that the variable names
# in direction_data are the same as in the full model (Model 2), 
# and therefore plottable in the same coordinate system as the regression surface. 
# Model 2 is not used to estimate any values.
# The function will be edited in the future to ensure there is no confusion.
```
