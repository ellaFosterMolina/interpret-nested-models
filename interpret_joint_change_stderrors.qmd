```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", 
  warning = F,
  message = F
)
```

```{r, include = FALSE}
library(regress3d)
library(plotly)
library(stargazer)
la_counties <- subset(county_data, state_abbrv == "LA")
model1 <- lm(prcnt_GOP16 ~ median_income16_1k,  data = la_counties)
model2 <- lm(prcnt_GOP16 ~ median_income16_1k + prcnt_black, data = la_counties)
model3 <- lm(prcnt_black ~ median_income16_1k, data = la_counties)

```

# Joint Changes and Standard Errors

## Interpreting joint changes in $x_1$ and $x_2$

The nested model (Model \ref{ypredbyx1}) and the direction plotted in Model \ref{ypredbyx1x2} both reflect the change in `prcnt_GOP16` as `median_income16_1k` and `prcnt_black` jointly change. The joint change is specified by Model \ref{x1predbyx2}, where a one unit change in `median_income16_1k` (\$1,000) is associated with a **-0.707\%** change in the percent of the county identifies as Black (`prcnt_black`).

Therefore, we can say that the nested model reflects that a joint one unit change in `median_income16_1k` (\$1,000) **and** a **-0.707\%** change in `prcnt_black` predicts a 0.364 unit change in `prcnt_GOP16`.

```{r, results = 'asis'}
stargazer(model1, model2, model3, 
          # type = "text",
          type = "html",
          model.numbers = F,
          column.labels =  c("1","2","3"))
```

## A Possible Approach to Extracting Standard Errors

The standard errors for the [green]{style="color: green;"} line above that shows the confidence interval of Model \ref{ypredbyx1x2} are difficult to recover using mainstream statistical methods. 

### Residuals model 

A similarly small standard error on `median_income16_1k` can be recovered by estimating `prcnt_GOP16` using both `median_income16_1k` and the *residuals* of `prcnt_black` from Model \ref{x1predbyx2}.

First, add a column of residual values to `la_counties`.

```{r}
la_counties$resid_black_predby_income <- residuals(model3)
```

Then we estimate Model \ref{ypredbyx1resids}

\begin{align}
y =& \beta_1^{''} x_1 +\beta_2^{''} x^{''}_2 + \beta^{''}_0 +\epsilon^{''} \label{ypredbyx1resids}\\
\text{% GOP} =& \beta^{''}_1*\text{median-income16} + \beta^{''}_1*\text{resid-black-predby-income}+\beta^{''}_0 + \epsilon^{''} \nonumber
\end{align}

```{r}
la_counties$resid_black_predby_income_shifted <- la_counties$resid_black_predby_income +
  mean(la_counties$prcnt_black,na.rm=T)
model_blackresids <- lm(prcnt_GOP16~median_income16_1k+resid_black_predby_income, 
                        data = la_counties)
```

Finally, we compare the results from three models:
  
  * Model \ref{ypredbyx1}: `prcnt_GOP16` ~ `median_income16_1k`
* Model \ref{ypredbyx1x2}: `prcnt_GOP16` ~ `median_income16_1k` + `prcnt_black`
* Model \ref{ypredbyx1resids}: `prcnt_GOP16` ~ `median_income16_1k` + `resid_black_predby_income`

```{r, results = 'asis'}
stargazer(model1, model2, model_blackresids, 
          # type = "text",
          type = "html",
          model.numbers = F,
          column.labels =  c("1","2","4"))
```

### Takeaways

* The coefficients for `median_income16_1k` in Models \ref{ypredbyx1} and \ref{ypredbyx1resids} are identical. 
* As expected, the standard errors are different in Models \ref{ypredbyx1} and \ref{ypredbyx1resids}.
* The indicators of overall model fit are identical for Models \ref{ypredbyx1x2} and \ref{ypredbyx1resids}. 

The proof of how the standard error for `median_income_1k` in Model \ref{ypredbyx1resids} relates to the standard error of the green line plotted in the figure above is in progress.
```{r, include = F, eval=F}
#mean centering variables
x1 <-la_counties$median_income16_1k - mean(la_counties$median_income16_1k , na.rm=T)
x2 <-la_counties$prcnt_black - mean(la_counties$prcnt_black , na.rm=T)
x <- cbind(x1,x2)
y <- la_counties$prcnt_GOP16 - mean(la_counties$prcnt_GOP16 , na.rm=T)

# Calculating variance and std dev
sigma_full <- summary(model2)$sigma^2
#hand calculating sigma_full
beta <- summary(tmp)$coefficients[c("x1", "x2"), "Estimate"]
(t(y)%*%y - t(beta)%*%t(x)%*%y)/(length(x1)-length(beta)-1)
# double checking variance in mean centered model
tmp <- lm(y~x1+x2) 
summary(tmp)$sigma^2 #var in mean centered model is same

x1transpx1inv <-( t(x1)%*%x1 )^(-1)

xtranspxinv <-( t(x)%*%x )^(-1)
gamma <- summary(model3)$coefficients["median_income16_1k","Estimate"]
gamma <- x1transpx1inv%*%t(x1)%*%x2
gamma_mat <- matrix(c(1, gamma), ncol = 2)

#calculating variance for rotated variables
var <- sigma_full*gamma_mat%*%xtranspxinv%*%t(gamma_mat)
sqrt(var)

# trying to create rotated x vars
rotation_matrix <- matrix(c(1, gamma, -gamma, 1), nrow = 2)
a <- rotation_matrix[1,1]
b <- rotation_matrix[2,1]
rotation_matrix <- rotation_matrix*(1/sqrt((a^2 + b^2) ))
a <- rotation_matrix[1, 1]
b <- rotation_matrix[2, 1]
mean_x1 <- mean(la_counties$median_income16_1k , na.rm=T)
mean_x2 <- mean(la_counties$prcnt_black , na.rm=T)

la_counties$rotation1 <- a*la_counties$median_income16_1k +b*la_counties$prcnt_black  - a*mean_x1 - b*mean_x2
la_counties$rotation.orth <- -b*la_counties$median_income16_1k +a*la_counties$prcnt_black  + b*mean_x1 - a*mean_x2

units.of.x1.adjustment <- 1/sqrt(1^2 + gamma^2)
la_counties$rotation1_adj <- la_counties$rotation1*units.of.x1.adjustment
la_counties$rotation.orth_adj <- la_counties$rotation.orth*units.of.x1.adjustment

lm(la_counties$prcnt_GOP16 ~la_counties$rotation1 +la_counties$rotation.orth) %>% summary(.)
lm(la_counties$prcnt_GOP16 ~la_counties$rotation1_adj +la_counties$rotation.orth_adj) %>% summary(.)
model_rotated <- lm(la_counties$prcnt_GOP16 ~la_counties$rotation1_adj +la_counties$rotation.orth_adj) 

x1_r <- la_counties$rotation1_adj
x2_r <- la_counties$rotation.orth_adj

x_r <- cbind(1, x1_r, x2_r)
xtranspxinv_r <-( t(x_r)%*%x_r )^(-1)
var_r <- sigma_full*xtranspxinv_r[1,1]
var_r <- sigma_full*xtranspxinv_r[2,2]
sqrt(var_r)

stargazer(model1, model2, model_eduresids, model_rotated,
          type = "text",
          # type = "html",
          model.numbers = F,
          column.labels =  c("1","2","residuals", "rotated"))

```


```{r, include=F, eval = F}
plot_ly( data = la_counties,
         x = ~median_income16_1k,
         y = ~prcnt_black,
         z = ~prcnt_GOP16) %>%
  add_markers(size = ~pop_estimate16, color = I("black"),
              name = "Louisiana counties") %>%
  add_3d_surface(model = model2)%>%
  add_marginals(model = model2,
                omit_x1=T,
                x2_direction_name ="Marginal effect of education")%>%
  # add_3d_surface(model = model_eduresids)%>%
  # add_marginals(model = model_eduresids,
  #               x1_direction_name ="Marginal effect of income",
  #               x1_color = "grey",
  #               x2_direction_name ="Marginal effect of the residuals of education",
  #               x2_color = "darkgrey")
  # add_direction(model = model2, direction_data = simulated_data_nested_model,
  #               direction_name = "Nested model: prcnt_GOP16 ~ median_income16_1k,<br> omitting prcnt_black") %>%
  add_direction(model = model2, direction_data = simulated_data_model2,
                linecolor = "green",
                direction_name = "A direction in Model 2:<br>prcnt_GOP16 ~ median_income16_1k + prcnt_black")
```
